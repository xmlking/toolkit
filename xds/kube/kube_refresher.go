package kube

import (
	"context"
	"time"

	"github.com/envoyproxy/go-control-plane/pkg/cache/v3"
	xlog "github.com/envoyproxy/go-control-plane/pkg/log"
	"github.com/envoyproxy/go-control-plane/pkg/resource/v3"
	"github.com/rs/zerolog/log"
	"github.com/xmlking/toolkit/xds/api"
	"go.opentelemetry.io/otel/metric"
	"go.opentelemetry.io/otel/metric/global"
	"go.opentelemetry.io/otel/metric/unit"
	"golang.org/x/sync/errgroup"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/clientcmd"
)

type kubeRefresher struct {
	refreshInterval time.Duration
	ctx             context.Context
	nodeID          string

	client         kubernetes.Interface
	namespace      string
	servicesCache  cache.SnapshotCache
	endpointsCache cache.SnapshotCache
	muxCache       cache.Cache

	telemetry bool
	snapshots metric.Int64Counter
	errors    metric.Int64Counter
}

var _ api.Refresher = (*kubeRefresher)(nil)

func mapTypeURL(typeURL string) string {
	switch typeURL {
	case resource.ListenerType, resource.RouteType, resource.ClusterType:
		return "services"
	case resource.EndpointType:
		return "endpoints"
	default:
		return ""
	}
}

func NewKubeRefresher(ctx context.Context, refreshInterval time.Duration, nodeID string, namespace string, logger xlog.Logger) api.Refresher {
	meter := global.Meter("otel-dns-refresher")

	clientConfig, err := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(clientcmd.NewDefaultClientConfigLoadingRules(), nil).ClientConfig()
	if err != nil {
		log.Fatal().Stack().Err(err).Str("component", "xds").Msg("Fail to create Kubernetes client config")
	}
	k8sClient, err := kubernetes.NewForConfig(clientConfig)
	if err != nil {
		log.Fatal().Stack().Err(err).Str("component", "xds").Msg("Fail to create Kubernetes client")
	}

	servicesCache := cache.NewSnapshotCache(false, cache.IDHash{}, logger)
	endpointsCache := cache.NewSnapshotCache(false, cache.IDHash{}, logger)

	muxCache := cache.MuxCache{
		Classify: func(r *cache.Request) string {
			return mapTypeURL(r.TypeUrl)
		},
		ClassifyDelta: func(r *cache.DeltaRequest) string {
			return mapTypeURL(r.TypeUrl)
		},
		Caches: map[string]cache.Cache{
			"services":  servicesCache,
			"endpoints": endpointsCache,
		},
	}

	k8r := &kubeRefresher{
		ctx:             ctx,
		refreshInterval: refreshInterval,
		nodeID:          nodeID,

		client:    k8sClient,
		namespace: namespace,

		servicesCache:  servicesCache,
		endpointsCache: endpointsCache,
		muxCache:       &muxCache,
	}

	k8r.snapshots, err = meter.NewInt64Counter(
		"snapshots",
		metric.WithDescription("Number of snapshots generated by xds-controller"),
		metric.WithUnit(unit.Dimensionless),
	)
	if err != nil {
		log.Warn().Err(err).Str("component", "xds").Msg("Telemetry not enabled")
	} else {
		k8r.telemetry = true
	}

	k8r.errors, err = meter.NewInt64Counter(
		"errors",
		metric.WithDescription("Number of errors happened in xds-controller"),
		metric.WithUnit(unit.Dimensionless),
	)
	if err != nil {
		log.Warn().Err(err).Str("component", "xds").Msg("Telemetry not enabled")
	} else {
		k8r.telemetry = true
	}

	return k8r
}

func (k *kubeRefresher) GetCache() cache.Cache {
	return k.muxCache
}

func (k *kubeRefresher) Start() error {
	group, groupCtx := errgroup.WithContext(k.ctx)
	group.Go(func() error {
		return k.startServices(groupCtx)
	})
	group.Go(func() error {
		return k.startEndpoints(groupCtx)
	})
	return group.Wait()
}
